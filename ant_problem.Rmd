---
title: "Ant Problem"
output: html_notebook
author: "Ryan Gan"
date: "208-04-26"
editor_options: 
  chunk_output_type: inline
---

## Question:

An ant is on a rectangular n×m grid with southwest-most point (0,0)a nd northeast-most point (n,m). Starting at (0,0), each time, the ant travels along a path walking north or east by a unit length on the grid with equal probability until it reaches (n,m). Define the deviation D of a path (from the straight path) as max(x/m−y/n,y/n−x/m) for all points (x,y) along the path. Here I define n=x, and m=y.

## General Solution:

My first thought is that this problem can be solved by a Markov Chain, where the next state (next location of ant) only depends on it's current state (current location of ant). It has a 50% chance to go north, or %50 chance to go east on the defined grid. The ant needs to stop when it either reaches x = 7 or y = 11. I can then calculate deviation of a path, D. I'd then repeat this process i number of times to get a distribution of paths and Ds. Then I can take the mean and standard deviation of the D. 

### Solution for the n x m, 7 row, 11 column matrix E

I am assuming here that n x m represents a row x column matrix. So the northeast-most point of (n = 7, m = 11) corresponds with (x,y) coordinates of (10,6).

Using tidyverse library.
```{r setup}
library(tidyverse)
```


```{r visualize_grid}
n <- 7 # n rows
m <- 11 # m cols
# visualize matrix
ant_mat <- matrix(nrow = n, ncol = m)
dim(ant_mat)
# set rows and cols
rownames(ant_mat) <- ((n-1):0)
colnames(ant_mat) <- (0:(m-1))
```

Creating an expanded grid of coordinates.
```{r path_function}
# simulated ant path function
ant_path_fun <- function(i = 1, n = 7, m = 11){
  # create empty dataframe
  ant_path <- data.frame(matrix(nrow = 1, ncol = 6))
  # name columns
  colnames(ant_path) <- c("i", "step", "direction", "x", "y", "D")
  # define origin
  x <- y <- 0
  # define step
  step <- 0
  # set first values for ant path df
  ant_path[1,] <- c(i, step,"none", x, y, 0)

  # while loop to stop when ant reaches northeast corner (m-1,n-1)
  while(x < (m-1) | y < (n-1)) {
      step <- step + 1
      direction <- sample(c("east", "north"), 1, prob = c(0.5, 0.5)) 
      # next cell location based on direction
        if(direction == "east"){
          if(x < (m-1)) {x <- x + 1} else{ y <- y + 1 }
        } else {
          if(y < (n-1)) {y <- y +1} else{ x <- x + 1}
        }
      # calcuate D at each step
      D <- max(c((x/m)-(y/n), ((y/n) - (x/m))))
      ant_path <- rbind(ant_path, c(i, step, direction, x, y, D))
      ant_path$D <- as.numeric(ant_path$D)
  } # end while function
  ant_path
}
```

One ant.
```{r}
# one ant
one_ant <- ant_path_fun(i=1, n=7, m=11) %>% 
  filter(step != 0)

# mean and sd of one ant
print(c(mean(one_ant$D), sd(one_ant$D)))
```

Function should work. Using the map function from purrr package to create a dataframe with paths and D calcuation for 1000 simulated ants.

```{r simulate_multiple_ants}
# simulate 1000 ants to generate distribution of ant paths to infer from
sim_ants_n7_m11 <- 1:1000 %>% 
  # purrr::map_dfr function
  map_dfr(., ~ant_path_fun(i = ., n=7, m=11)) %>% 
  # remove origin step from mean and sd calc
  filter(step != 0)

# 10 digit mean of all ants
format(mean(sim_ants_n7_m11$D), digits = 10)
# 10 digit sd of all ants
format(sd(sim_ants_n7_m11$D), digits = 10)
```

Simulating 1000 ants m = 23, n = 31.


```{r simulate_multiple_ants_m23_n31}
# m=23,n=21 simulate 1000 ants 
sim_ants_m23_n21 <- 1:1000 %>% 
  # purrr::map_dfr function
  map_dfr(., ~ant_path_fun(i = ., n=21, m=23)) %>% 
  # remove origin step from mean and sd calc
  filter(step != 0)

# 10 digit mean of all ants
format(mean(sim_ants_m23_n21$D), digits = 10)
# 10 digit sd of all ants
format(sd(sim_ants_m23_n21$D), digits = 10)
```

What is the conditional probability that D is greater than 0.6 given that it is greater than 0.2 when m=11 and n=7?

```{r conditional_prob_simants_n7_m11}
# conditional probability that D > 0.6 | D > 0.2
sim_ants_n7_m11_prob <- sim_ants_n7_m11 %>% 
  # create binary indicators of 2 probs
  mutate(prob_6 = ifelse(D > 0.6, 1, 0),
         prob_2 = ifelse(D > 0.2, 1, 0))

# D > 0.6 | D > 0.2
format(prop.table(xtabs(~prob_6 + prob_2, sim_ants_n7_m11_prob),2), nsmall=10)
```

What is the conditional probability that D is greater than 0.6 given that it is greater than 0.2 when m=23 and n=31?

```{r conditional_prob_simants_n31_m23}
# conditional probability that D > 0.6 | D > 0.2
sim_ants_m23_n21_prob <- sim_ants_m23_n21 %>% 
  # create binary indicators of 2 probs
  mutate(prob_6 = ifelse(D > 0.6, 1, 0),
         prob_2 = ifelse(D > 0.2, 1, 0))

# D > 0.6 | D > 0.2
format(prop.table(xtabs(~prob_6 + prob_2, sim_ants_m23_n21_prob),2), nsmall = 10)
```

I think this answers the simulated ant path question. I could do some more complicated pooled estimates of mean and standard deviation accounting for ant paths, but that seems to complicate matters.